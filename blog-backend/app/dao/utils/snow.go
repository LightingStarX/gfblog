package utils

import (
	"github.com/gogf/gf/errors/gerror"
	"math/rand"
	"sync"
	"time"
)

// @Author: OxCAFFEE
// @Github: https://github.com/OxCaffee
// @Email: wwh2021@mail.ustc.edu.cn
// @Date: 2021/8/11-15:59

// This package is for uid generation under the distributed environment.
// The algorithm is quite or a little different from origin snow algorithm
// since we may need to generate uid with flexible number of bits or
// other format like hex character. In one word, it depends on your needs.
//
// In this project, we will make the generated uid more identical for each
// database table. For example, the algorithm will distinguish each database
// table and generate each table independently, so although each uid different
// from each other in same table, they still have same bits in common.
//

const (
	// The number of this table in this project will not exceed 2^10 (which is 512),
	// so we assign 10 bit to identify each table. These bits are located on the left
	// of sequence bits.
	tableIdBits = uint64(10)

	// We assign 12 bits to represent sequence number. The sequence number is the time code
	// generated by the same machine at the same time(in milliseconds format).
	sequenceIdBits = uint64(12)

	// Between +/- bit and tableId bits is the times bits, in 64bits machine, it is 41 bits.
	timeStampBits = uint64(41)

	// To prevent id overflows.
	maxTableId    = int64(-1) ^ (int64(-1) << tableIdBits)
	maxSequenceId = int64(-1) ^ (int64(-1) << sequenceIdBits)

	// timeStamp left shifting bits
	timeStampLShiftBits = uint64(22)
	// TableId left shifting bits
	tableIdLShiftBits = uint64(12)
)

type TableWorker struct {
	mux sync.Mutex
	// // last timestamp
	LastTimeStamp uint64
	// table id
	TableId uint64
	// ID sequence number that has been generated in the current millisecond (accumulated from 0)
	// A maximum of 4096 ids can be generated in 1 millisecond
	SequenceId uint64
}

var (
	// const timestamp value, initialize it in init function, once assigned, never changed
	constTimestamp uint64
)

func init() {
	constTimestamp = uint64(time.Now().UnixNano() / 1e6)
}

// NewTableWorker using table name to create a table worker for uuid generation
func NewTableWorker(tableName string) *TableWorker {
	return &TableWorker{
		LastTimeStamp: constTimestamp,
		TableId:       uint64(TableMap[tableName]),
		SequenceId:    rand.Uint64() & 0x3,
	}
}

// Get current time in milliseconds format
func (w *TableWorker) getMilliSeconds() int64 {
	return time.Now().UnixNano() / 1e6
}

// NextID obtains the next uid for current table
func (w *TableWorker) NextID() (uint64, error) {
	w.mux.Lock()
	defer w.mux.Unlock()

	return w.nextID()
}

func (w *TableWorker) nextID() (uint64, error) {
	ts := uint64(w.getMilliSeconds())
	if ts < w.LastTimeStamp {
		return 0, gerror.New("Stale dated timestamp")
	}

	// same timestamp, different sequence id
	if ts == w.LastTimeStamp {
		w.SequenceId = (w.SequenceId + 1) & uint64(maxSequenceId)
		if w.SequenceId == 0 { // sequenceId overflowed
			for {
				if ts < w.LastTimeStamp {
					ts = w.LastTimeStamp
				}
			}
		}
	} else {
		// different timestamp, sequence restart from 0
		w.SequenceId = 0
	}

	w.LastTimeStamp = ts
	id := ((w.LastTimeStamp - constTimestamp) << timeStampLShiftBits) | (w.TableId << tableIdLShiftBits) | w.SequenceId
	//// to format all ids in same length, we set the highest bit to 1
	//id |= 1 << 63
	return uint64(id), nil
}
