// =================================================================================
// This is auto-generated by GoFrame CLI tool only once. Fill this file as you wish.
// =================================================================================

package dao

import (
	"blog-backend/app/dao/internal"
	"blog-backend/app/dao/utils"
	"blog-backend/app/model"
	"context"
	"github.com/gogf/gf/database/gdb"
	"github.com/gogf/gf/frame/g"
)

// roleDao is the manager for logic model data accessing and custom defined data operations functions management.
// You can define custom methods on it to extend its functionality as you wish.
type roleDao struct {
	*internal.RoleDao
}

var (
	// Role is globally public accessible object for table role operations.
	Role       roleDao
	roleWorker *utils.TableWorker
)

func init() {
	Role = roleDao{
		internal.NewRoleDao(),
	}
	roleWorker = utils.NewTableWorker(Role.Table)
}

func (d *roleDao) GetRoleNameByUid(uid uint64) (string, bool) {
	if uid == 0 {
		return "", false
	}
	m, err := g.Model(Role.Table).Where(Role.C.Uid, uid).One()
	if err != nil {
		return "", false
	}
	return m[Role.C.RoleName].String(), true
}

func (d *roleDao) GetRoleUidByName(roleName string) (uint64, bool) {
	if roleName == "" {
		return 0, false
	}
	m, err := g.Model(Role.Table).Where(Role.C.RoleName, roleName).One()
	if err != nil {
		return 0, false
	}
	return m[Role.C.RoleName].Uint64(), true
}

// AddRole mode.Role.uid 不能由自己设置，而应该交给雪花算法自动生成
func (d *roleDao) AddRole(role model.Role) bool {
	if role.RoleName == "" {
		return false
	}

	id, err := roleWorker.NextID()
	if err != nil {
		return false
	}

	role.Uid = id
	_, e := g.Model(Role.Table).OmitEmpty().Insert(role)
	if e != nil {
		return false
	}
	return true
}

// UpdateRoleName 一般情况下，不应该在直接修改uid，而是将uid作为定位的依据
func (d *roleDao) UpdateRoleName(role model.Role) bool {
	if role.Uid == 0 {
		return false
	}

	// 注意，更新 role 操作并不会触发更新 model.Role.uid，既然不涉及级联删除，那么就不需要保持在事务当中
	_, err := g.Model(Role.Table).OmitEmpty().Where(Role.C.Uid, role.Uid).Insert(role)
	if err != nil {
		return false
	}
	return true
}

// DeleteRole 删除角色，删除角色的同时应该删除映射表里面的内容
func (d *roleDao) DeleteRole(role model.Role) bool {
	if role.Uid == 0 {
		return false
	}
	// 删除 role 和 删除 user_role_mapping 应该在同一个事务当中
	err := g.DB().Transaction(context.TODO(), func(ctx context.Context, tx *gdb.TX) error {
		_, e := tx.Ctx(ctx).Model(Role.Table).Where(Role.C.Uid, role.Uid).Delete()
		if e != nil {
			// 删除失败，尝试回滚
			e = tx.Rollback()
			// 回滚失败，返回错误
			if e != nil {
				panic(e)
			}
		} else {
			// 从 role 表中删除成功，继续从 user_role_mapping 中删除
			_, e = tx.Ctx(ctx).Model(UserRoleMapping.Table).Where(UserRoleMapping.C.RoleUid, role.Uid).Delete()
			if e != nil {
				e = tx.Rollback()
				if e != nil {
					panic(e)
				}
			}
		}
		return nil
	})
	if err != nil {
		return false
	}
	return true
}

func checkRoleByUid(uid uint64) bool {
	if uid == 0 {
		return false
	}
	c, err := g.Model(Role.Table).Where(Role.C.Uid, uid).Count()
	if err != nil || c == 0 {
		return false
	}
	return true
}

func checkRoleByName(name string) bool {
	if name == "" {
		return false
	}

	c, err := g.Model(Role.Table).Where(Role.C.RoleName, name).Count()
	if err != nil || c == 0 {
		return false
	}
	return true
}
